# Simple Object Manager (SOM) Cheat Sheet
This page is to provide a summary of all functions and options available

| Method Type | Method      | Description    | example |
| ------------| ----------- | -----------    |---------
| Instantiation| new Som()   | simple instantiation  | ```let mySom = new Som() ```
| Instantiation| new Som({..})    | instantiation with object | ```let mySom = new Som({'foo':'bar'}) ```
| Instantiation| new Som(som1) | instantiation with Som instances |  ```let mySom = new Som(myOldSom) ```
| Instantiation| new Som({},{'dv':'defaultValue'}) | simple instantiation and changing the default value returned when key not present on getter (`undefined`) by passing an `option` object such as `'options.dv'` |  ```let mySom = new Som({},{'dv':defaultValue'}) ```
| Instantiation | new Som(myObj,{'dv':undefined,'deepcopy':false}) | instantiation with an existing object, keeping `undefined` as default value returned on the getter but do not deep copy the object. Any change will be repercuter to the Object. (non default behavior)|  ```let myObj = {"foo":"bar"};```<br/>```let mySom = new Som(myObj,{'dv':undefined,'deepcopy':false}) ```
| Instantiation | new Som(myObj,{'stack':true,'context':()=>{return 'myExample'}}) | instantiation with an existing object, but setting the `option.stack` field to `true` to provide a stack object on Som instance, that will keep track of all the methods used during the SOM lifetime. You can also pass a function on the `context` parameter (non default behavior)|  ```let myObj = {"foo":"bar"};```<br/>```let mySom = new Som(myObj,{'stack':true,'context':()=>{return 'myExample'}}) ```<br/>```mySom.get('foo') // returns bar ```<br/>```mySom.stack // provide [{'method':'get','path':'foo':'context':'myExample'}] ```
| Instantiation | mySubSom = mySom.subSom(path) | instantiation of a Som Object out of an existing Som Object, it returns an instance of Som linked to the main Som object. |  ```let myObj = {'myObject':{'level1':{'example':'value'}}};```<br/>```let mySom = new Som(myObj) ```<br/>```mySubSom = mySom.subSom('myObject.level1') // returns {'example':'value'} ```<br/>```mySubSom.assign('foo','bar')``` <br/> ``` mySom.get('myObject.level1')// returns {"example":"value","foo":"bar"} ```
| Getter | .get('path.object') | getter to a specific path will never error out. Nested object are represented with the dot (.) notation. <br/>Provide a default value when key not present in the object. (see instanciation methods) | ``` mySom.get('my.nested.key')```<br/>``` //will return "bar" in the following object ```<br/>``` {my:{nested:{'key':'bar'}}}```
| Getter | .get() | global getter. It will return the whole object in Som. | ``` mySom.get()```<br/>``` //will return the whole object```<br/>``` {my:{nested:{'key':'bar'}}}```
| Getter | .get('path.0.key') | getter to a specific path contain in an array. Array elements can be access by their index with the dot (.) notation. <br/>Provide a default value when key not present in the object. (see instanciation methods) | ``` mySom.get('my.nested.0.key')```<br/>``` //will return "bar" in the following object ```<br/>``` {my:{nested:[{'key':'bar'}]}}```
| Getter | .get('path.0.missingKey','newDefault') | getter to a specific path contain in an array. Overriding the defaultValue set during instanciation | ``` mySom.get('my.nested.0.missingKey')```<br/>``` //will return "newDefault" in the following object ```<br/>``` {my:{nested:[{'key':'bar'}]}}```
| Setter | .assign('path.0.missingKey','baz') | set a value and create the nested element if required, following the specific path provided with dot notation. Works on normal object and array. | ``` mySom.assign('my.nested.0.missingKey','baz')```<br/>``` //will set "baz" in the following object ```<br/>``` {my:{nested:[{'key':'bar','missingKey':'baz'}]}}```
| Setter | .assign('path.0.missingKey',value,'default') | set a value and specify which default value to create in case `value` is not define, create the nested element if required, following the specific path provided with dot notation. Works on normal object and array. | ``` let value``` <br/>``` mySom.assign('my.nested.0.missingKey',value,'baz')```<br/>``` //will set "baz" in the following object ```<br/>``` {my:{nested:[{'key':'bar','missingKey':'baz'}]}}```
| Merger | .merge(object) | merge the existing object in Som with the new obj. Som data is changed, **nothing** is returned | ``` let newObj = {'foo':'bar'}``` <br/>``` let mySom = new Som({'key':'value'})``` ```mySom.merge(newObj)```<br/>``` //will set the following object in Som ```<br/>``` {'foo':'bar','key':'value'}```
| Merger | .merge(path, object) | merge the existing object found in that path with the new obj. Som data is changed, **nothing** is returned | ``` let newObj = {'foo':'bar'}``` <br/>``` let mySom = new Som({'key':'value','nested':{'foo':'bar'}})``` ```mySom.merge('nested',newObj)```<br/>``` //will set the following object in Som ```<br/>``` {'foo':'bar','nested':{'key':'value','foo':'bar'}}```
| Merger | .mergeDeep(path,object) | merge the new object via recursion if needed in order to keep the existing key and value if needed. Simple array merge will extend the existing array with the new elements. Som data is changed, **nothing** is returned | ``` let newObj = {'foo':'bar','array':['value2']}``` <br/>``` let mySom = new Som({'key':'value','array':['value1']})``` ```mySom.mergeDeep(newObj)```<br/>``` //will set the following object in Som ```<br/>``` {'foo':'bar','key':'value','array':['value1','value2']}```
| Pusher | .push(path, element,override=false) | push the element to that path with the new obj. You can override the existing value or just keep the existing value (default behavior) | ``` let mySom = new Som({'key':'value'})``` ```mySom.push('myarray','something')```<br/>``` //will set the following object in Som ```<br/>``` {'key':'value','myarray':[something]}```<br/>```mySom.push('key','something')```<br/>``` //will set the following object in Som ```<br/>``` {'key':['value','something'],'myarray':[something]}```
| Replacer | .replace(old_value, new_value) | replace the value provided in the `old_value` parameter by the new value provided everywhere in the Som object. Som data is changed, **nothing** is returned | ``` let mySom = new Som({'key':'value'})``` ```mySom.replace('value','something')```<br/>``` //Som object will contain the following element ```<br/>``` {'key':'something.'}```
| Searcher | .searchValue(value, regex) | search and returns the paths that leads to the `value` defined as parameter. You can pass `true` in the second parameter to use regular expression search. An object is returned with the key being the value searched, the result an array of path leading to that value| ``` let mySom = new Som({'key':{'level1'.value'}})``` ```mySom.search('value')```<br/>```\\ result will be  {'value':['key.level1']}```
| Remover | .remove(path.object) | remove a specific part of the existing object in Som. Som data is changed, **nothing** is returned | ```let mySom = new Som({'key':'value','foo':'bar'})``` ``` mySom.remove("key")```<br/>``` //Som will now contain ```<br/>``` {'foo':'bar','key':undefined}```
| Remover | .remove(path.object,key=true) | remove a specific part of the existing object in Som and the key associated. Som data is changed, **nothing** is returned | ```let mySom = new Som({'key':'value','foo':'bar'})``` ``` mySom.remove("key",key=true)```<br/>``` //Som will now contain ```<br/>``` {'foo':'bar'}```
| Remover | .remove() | Clear the whole object. Som data is changed, **nothing** is returned | ```let mySom = new Som({'key':'value','foo':'bar'})``` ``` mySom.remove()```<br/>``` //Som will now contain ```<br/>``` {}```
| Remover | .clear() | equivalent of `.remove()` with no parameter. Som data is changed, **nothing** is returned | ```let mySom = new Som({'key':'value','foo':'bar'})``` ``` mySom.clear()```<br/>``` //Som will now contain ```<br/>``` {}```